--[[
Этот файл — часть Darkbox.

Darkbox — свободная программа: вы можете перераспространять ее и/или
изменять ее на условиях Стандартной общественной лицензии GNU в том
виде, в каком она была опубликована Фондом свободного программного
обеспечения; либо версии 3 лицензии, либо (по вашему выбору) любой
более поздней версии.

Darkbox распространяется в надежде, что она будет полезной, но БЕЗО
ВСЯКИХ ГАРАНТИЙ; даже без неявной гарантии ТОВАРНОГО ВИДА или
ПРИГОДНОСТИ ДЛЯ ОПРЕДЕЛЕННЫХ ЦЕЛЕЙ. Подробнее см. в Стандартной
общественной лицензии GNU.

Вы должны были получить копию Стандартной общественной лицензии GNU
вместе с этой программой. Если это не так, см.
<https://www.gnu.org/licenses/>.
]]

local ID = {
	ARROW = hash("/arrow"),
	PAYPHONE = hash("/payphone"),
	POSITION = {
		Y = hash("position.y")
	}
}

local URL = {
	MCTL = msg.url("game:/player#mission"),
	PLAYER = msg.url("game:/player")
}

local MSG = {
	LOAD_MAP = hash("load_map"),
	ADD = hash("add"),
	TOGGLE = hash("toggle"),
	UPDATE_LIST = hash("update_list")
}

local FACTORY = {
	PAYPHONE = msg.url("game:/factory#payphone"),
	TARGET_PTR = msg.url("game:/factory#target_ptr")
}

local PAYPHONES = {}
local TARGET_PTRS = {}

local function add_object(obj, notify)
	local TYPE = obj.type
	local AFFECTED;
	
	if TYPE == "payphone" then
		local instance = collectionfactory.create(FACTORY.PAYPHONE, obj.position)
		PAYPHONES[#PAYPHONES+1] = instance
		AFFECTED = PAYPHONES

		go.animate(instance[ID.ARROW], ID.POSITION.Y, go.PLAYBACK_LOOP_PINGPONG, -60, go.EASING_INOUTSINE, 2)
	elseif TYPE == "target_ptr" then
		local instance = collectionfactory.create(FACTORY.TARGET_PTR, obj.position)
		TARGET_PTRS[#TARGET_PTRS+1] = instance
	else
		error("unknown type: " .. TYPE, 2)
	end

	if notify then
		msg.post(URL.MCTL, MSG.UPDATE_LIST, {
			type = TYPE,
			list = AFFECTED
		})
	end

	collectgarbage()
end

local function toggle_object(data)
	local CLASS, OBJ_ID, MODE = data[1], data[2], data[3]

	if MODE == true then
		MODE = "enable"
	elseif MODE == false then
		MODE = "disable"
	else
		error(string.format("invalid mode '%s'", MODE), 2)
	end

	if CLASS == "payphone" then
		local payphone = assert(
			PAYPHONES[OBJ_ID],
			string.format("unable to fetch object of class %q with id %d", CLASS, OBJ_ID)
		)
		msg.post(payphone[ID.ARROW], MODE)
	else
		error(string.format("unknown object class %q", CLASS), 2)
	end
end

local function load_map(name)
	print("loading map: " .. name)

	-- 1. загрузка и установка объектов
	do
		local objects = {}

		local err = function (errmsg)
			print("FATAL: " .. errmsg)
			msg.post("@system:", "exit", {code = 1})
		end
		
		local payphone = function (tx, ty)
			return {
				type = "payphone",
				position = vmath.vector3(128*tx - 64, 128*ty - 64, 1),
			}
		end
		
		if name == "metacity" then
			objects.payphones = {
				payphone(7, 3),
				payphone(8, 3),
				payphone(9, 3),
				payphone(10, 3),
			}
		else
			print("FATAL: no such map: " .. name)
			msg.post("@system:", "exit", {code = 1})
		end

		for key, list in pairs(objects) do
			for id, obj in ipairs(list) do
				xpcall(function() add_object(obj, false) end, err)
			end
		end
	end collectgarbage()

	-- 2. сбор нужных данных об объектах и их отправка
	do
		-- ид телефонов
		local p_ids = {}
		
		----------------------------------------------------------------
		-- 2.1. сбор нужных данных
		
		for n, payphone in ipairs(PAYPHONES) do
			p_ids[#p_ids+1] = payphone[ID.PAYPHONE]
		end

		----------------------------------------------------------------
		-- 2.2. отправка данных

		msg.post(URL.MCTL, "set_payphones", p_ids)
	end collectgarbage()

	print("finished loading map")
end

function init(self)
	load_map("metacity")
end

function update(self, dt)
	do
		local player_pos = go.get_position(URL.PLAYER)
		
		for n, ptr in ipairs(TARGET_PTRS) do
			local arrow = ptr[ID.ARROW]
			local arrow_pos = go.get_position(arrow)
			local angle = vmath.quat_rotation_z(math.atan2(-player_pos.x + arrow_pos.x, player_pos.y - arrow_pos.y))
			go.set_rotation(angle, arrow)
		end
	end

	collectgarbage()
end

function on_message(self, message_id, message)
	if message_id == MSG.ADD then
		add_object(message, true)
	elseif message_id == MSG.TOGGLE then
		toggle_object(message)
	elseif message_id == MSG.LOAD_MAP then
		load_map(assert(message.name, error("expected field `name`", 2)))
	end
end