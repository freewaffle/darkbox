--[[
Этот файл — часть Darkbox.

Darkbox — свободная программа: вы можете перераспространять ее и/или
изменять ее на условиях Стандартной общественной лицензии GNU в том
виде, в каком она была опубликована Фондом свободного программного
обеспечения; либо версии 3 лицензии, либо (по вашему выбору) любой
более поздней версии.

Darkbox распространяется в надежде, что она будет полезной, но БЕЗО
ВСЯКИХ ГАРАНТИЙ; даже без неявной гарантии ТОВАРНОГО ВИДА или
ПРИГОДНОСТИ ДЛЯ ОПРЕДЕЛЕННЫХ ЦЕЛЕЙ. Подробнее см. в Стандартной
общественной лицензии GNU.

Вы должны были получить копию Стандартной общественной лицензии GNU
вместе с этой программой. Если это не так, см.
<https://www.gnu.org/licenses/>.
]]

local ACTION = {
	MOVE_FORWARD = hash("move_forward"),
	MOVE_BACKWARD = hash("move_backward"),
	MOVE_LEFT = hash("move_left"),
	MOVE_RIGHT = hash("move_right"),
	ENTER_VEHICLE = hash("enter_vehicle")
}

local MSG = {
	UPDATE_HP = hash("update_hp"),
	ENABLE = hash("enable"),
	DISABLE = hash("disable"),
	ACQ_INPUT = hash("acquire_input_focus"),
	REL_INPUT = hash("release_input_focus"),
	TRIG_RESP = hash("trigger_response"),
	ACTIVATE_MISSION = hash("activate_mission"),
	ASK_ENTER_VEHICLE = hash("ask_enter_vehicle"),
	ENTERED_VEHICLE_ID = hash("entered_vehicle_id"),
}

local ID = {
	-- player:

	THIS = msg.url("game:/player"),
	THIS_SCRIPT = msg.url("game:/player#script"),
	SPRITE = msg.url("game:/player#sprite"),
	SHADOW = msg.url("game:/player#shadow"),

	-- animations:

	ANIM = {
		PLAYER_MOVING = hash("player_moving"),
		PLAYER_STAND = hash("player_1"),
	},

	-- properties:

	PROP = {
		POSITION = hash("position"),
		ANIMATION = hash("animation"),
		ZOOM = hash("orthographic_zoom"),
	},

	-- external:

	-- mission controller
	MCTL = msg.url("game:/player#mission"),

	CAMERA = {
		THIS = msg.url("game:/camera"),
		CAM = msg.url("game:/camera#camera"),
	},

	TILEMAP = {
		THIS = msg.url("game:/map#tilemap"),
		GROUND = hash("ground")
	},

	MAP_CTL = msg.url("game:/map#script"),

	HUD = msg.url("game:/hud#hud"),

	GROUP = {
		PAYPHONE = hash("payphone")
	}
}

local TILEID = {
	WATER = 3
}

local CONST = {
	MOVEMENT_SPEED = 100,
	MAX_HP = 100,
	CAMERA_FOLLOWS_DIRECTION = true,
}

--------------------------------------------------------------------------------

local hp = CONST.MAX_HP
local dead = hp <= 0

local angle = vmath.quat()

local in_vehicle = nil

local function show_me(show)
	if show then
		msg.post(ID.THIS, MSG.ENABLE)
	else
		sprite.play_flipbook(ID.SPRITE, ID.ANIM.PLAYER_STAND)
		msg.post(ID.THIS, MSG.DISABLE)
	end
end

local function rotate_to_pos(target_position)
	-- FIXME: анимация свойства "rotation" вызывает ошибку
	-- go.animate("#sprite", "rotation", go.PLAYBACK_ONCE_FORWARD, to, go.EASING_OUTCUBIC, 0.5)
	angle = vmath.quat_rotation_z(math.atan2(target_position.x, -target_position.y))
	go.set_rotation(angle)
end

local function set_hp(to)
	if to == nil then
		to = CONST.MAX_HP
	else
		to = math.min(to, 0)
	end

	hp = to

	msg.post(ID.HUD, MSG.UPDATE_HP, {to})
end

local function get_current_tile(layer, pos)
	pos = pos or go.get_position()
	local TILESIZE = 128
	local tx, ty = math.floor(pos.x / TILESIZE) + 1, math.floor(pos.y / TILESIZE) + 1
	return tilemap.get_tile(ID.TILEMAP.THIS, layer, tx, ty)
end

local function tile_trigger(pos)
	if pos.x >= 0 and pos.y >= 0 then
		local tile_id = get_current_tile(ID.TILEMAP.GROUND, pos)
		if tile_id == TILEID.WATER then
			set_hp(0)
		end
	else
		set_hp(0)
	end
end

local function move_camera(to, duration, easing)
	if not duration then
		duration = 0
		easing = go.EASING_LINEAR
	end
	
	if not easing then
		easing = go.EASING_OUTCUBIC
	end
	
	go.animate(ID.CAMERA.THIS, ID.PROP.POSITION, go.PLAYBACK_ONCE_FORWARD, to, easing, duration)
end

local function zoom_camera(to, duration, easing)
	duration = duration or 0
	easing = easing or go.EASING_OUTCUBIC

	go.animate(ID.CAMERA.CAM, ID.PROP.ZOOM, go.PLAYBACK_ONCE_FORWARD, to, easing, duration)
end

--------------------------------------------------------------------------------

function init(self)
	self.velocity = vmath.vector3()
	
	----------------
	-- 1. intro pos

	local TX, TY = 7, 7
	local P = vmath.vector3((128 * TX) - 65, (128 * TY) - 65, 1)
	local M = 1

	go.set_position(P)
	go.set_position(vmath.vector3(P.x*M, P.y*M, P.z), ID.CAMERA.THIS)

	----------------
	-- 2. intro zoom

	--camera.set_orthographic_zoom(ID.CAMERA.CAM, 0.5)
	go.set(ID.CAMERA.CAM, "orthographic_zoom", 0.5)
	zoom_camera(1.5, 2)

	msg.post(ID.THIS_SCRIPT, MSG.ACQ_INPUT)
	collectgarbage()
end

function update(self, dt)
	local pos = go.get_position()
	
	if self.velocity.x ~= 0 or self.velocity.y ~= 0 and not in_vehicle then
		-- делает скорость при двунаправленном движении визуально симметричной
		-- к скорости с одним направлением
		if self.velocity.x ~= 0 and self.velocity.y ~= 0 then
			self.velocity = self.velocity * 0.8
		end

		go.set_rotation(angle)
		pos = go.get_position() + vmath.rotate(angle, (self.velocity * dt))
		go.set_position(pos)

		tile_trigger(pos)

		if CONST.CAMERA_FOLLOWS_DIRECTION and self.velocity.y ~= 0 then
			if self.velocity.y > 0 then
				pos = pos + vmath.rotate(angle, vmath.vector3(0, 128, 0))
			else
				pos = pos - vmath.rotate(angle, vmath.vector3(0, 128, 0))
			end
		end
		
		self.velocity = vmath.vector3()
	end

	local camera_pos = pos
	if in_vehicle then
		camera_pos = go.get_position(in_vehicle)
	end
	move_camera(camera_pos, 0.5, go.EASING_OUTCUBIC)

	dead = hp <= 0
	show_me(not (dead or in_vehicle))
	
	collectgarbage()
end

function on_message(self, message_id, message, sender)
	if message_id == MSG.TRIG_RESP then
		if message.group == ID.GROUP.PAYPHONE and message.enter then
			msg.post(ID.MCTL, MSG.ACTIVATE_MISSION, { payphone_id = message.other_id })
		end
	elseif message_id == MSG.ENTERED_VEHICLE_ID then
		in_vehicle = assert(message[1], "no vehicle id!")
	end
end

function on_input(self, action_id, action)
	if dead then return end

	local moved = false

	if action_id == ACTION.MOVE_FORWARD then
		self.velocity.y = CONST.MOVEMENT_SPEED
		moved = true
	elseif action_id == ACTION.MOVE_BACKWARD then
		self.velocity.y = -CONST.MOVEMENT_SPEED
		moved = true
	elseif action_id == ACTION.MOVE_LEFT then
		self.velocity.x = -CONST.MOVEMENT_SPEED
		moved = true
	elseif action_id == ACTION.MOVE_RIGHT then
		self.velocity.x = CONST.MOVEMENT_SPEED
		moved = true
	elseif action_id == ACTION.ENTER_VEHICLE and action.pressed then
		if in_vehicle then
			print("player: quit vehicle")

			local vpos = go.get_position(in_vehicle)
			local vrot = go.get_rotation(in_vehicle)
			
			go.set_position(vpos - vmath.rotate(vrot, vmath.vector3(128, 0, 0)))
			
			in_vehicle = nil
		else
			print("player: ask enter vehicle")
			msg.post(ID.MAP_CTL, MSG.ASK_ENTER_VEHICLE, {
				position = go.get_position(),
				range = 128 -- в пикселях
			})
		end
	elseif not action_id and action.x and action.y then
		local w, h = window.get_size()
		rotate_to_pos(vmath.vector3(w/2 - action.x, h/2 - action.y, 0))
	end

	if moved then
		local no_anim = go.get(ID.SPRITE, ID.PROP.ANIMATION) == ID.ANIM.PLAYER_STAND
		if action.pressed or no_anim then
			sprite.play_flipbook(ID.SPRITE, ID.ANIM.PLAYER_MOVING)
		elseif action.released then
			sprite.play_flipbook(ID.SPRITE, ID.ANIM.PLAYER_STAND)
		end
	end
	
	collectgarbage()
end