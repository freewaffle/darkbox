--[[
Этот файл — часть Darkbox.

Darkbox — свободная программа: вы можете перераспространять ее и/или
изменять ее на условиях Стандартной общественной лицензии GNU в том
виде, в каком она была опубликована Фондом свободного программного
обеспечения; либо версии 3 лицензии, либо (по вашему выбору) любой
более поздней версии.

Darkbox распространяется в надежде, что она будет полезной, но БЕЗО
ВСЯКИХ ГАРАНТИЙ; даже без неявной гарантии ТОВАРНОГО ВИДА или
ПРИГОДНОСТИ ДЛЯ ОПРЕДЕЛЕННЫХ ЦЕЛЕЙ. Подробнее см. в Стандартной
общественной лицензии GNU.

Вы должны были получить копию Стандартной общественной лицензии GNU
вместе с этой программой. Если это не так, см.
<https://www.gnu.org/licenses/>.
]]

local ID = {
	TILEMAP = {
		THIS = msg.url("game:/map#tilemap"),
		GROUND = hash("ground"),
		TRAFFIC = hash("[traffic]"),
	}
}

local MSG = {
	TRIG_RESP = hash("trigger_response"),
}

local TILESIZE = 128

local TILE = {
	WATER = 3,

	NAV = {
		CONTINUE = 7,
		STOP = 8,
		UP = 9,
		RIGHT = 10,
		DOWN = 11,
		LEFT = 12,
		ROTATE_TOP_LEFT = 13,
		ROTATE_TOP_RIGHT = 14,
		ROTATE_DOWN_LEFT = 15,
		ROTATE_DOWN_RIGHT = 16,
	},
}

go.property("index", 0)
go.property("traffic", false)

local function get_tile(layer, tx, ty)
	return tilemap.get_tile(ID.TILEMAP.THIS, layer, tx, ty)
end

local function get_tile_pos()
	local tx, ty
	do
		local pos = go.get_position()
		tx = math.floor(pos.x / TILESIZE) + 1
		ty = math.floor(pos.y / TILESIZE) + 1
	end
	return tx, ty
end

local function get_current_tile(layer)
	local tx, ty = get_tile_pos()
	return get_tile(layer, tx, ty)
end

--------------------------------------------------------------------------------

local function log(C, msg)
	print(string.format("car %d:\t\t%s", assert(C.index), msg))
end

local function update_velocity(C, vel)
	C.target_velocity = assert(vel, "nil velocity")
	C.prev_velocity = C.velocity
	C.time.acceleration = 0
end

local function stop(C)
	C.target_tile = nil
	update_velocity(C, 0)
end

local function tile_action(C)
	if not C.target_tile and C.traffic then
		log(C, "redefine target_tile")
		local tx, ty = get_tile_pos()
		C.target_tile = {
			x = tx,
			y = ty
		}
	end

	local tile = get_current_tile(ID.TILEMAP.TRAFFIC)
	local slow = false

	if tile == TILE.NAV.UP then
		C.target_tile.y = C.target_tile.y + 1
		C.direction = {
			x = 0,
			y = 1
		}
	elseif tile == TILE.NAV.RIGHT then
		C.target_tile.x = C.target_tile.x + 1
		C.direction = {
			x = 1,
			y = 0
		}
	elseif tile == TILE.NAV.DOWN then
		C.target_tile.y = C.target_tile.y - 1
		C.direction = {
			x = 0,
			y = -1
		}
	elseif tile == TILE.NAV.LEFT then
		C.target_tile.x = C.target_tile.x - 1
		C.direction = {
			x = -1,
			y = 0
		}
	elseif tile == TILE.NAV.CONTINUE then
		---------------------- X ----------------------
		if C.direction.x >= 1 then
			C.target_tile.x = C.target_tile.x + 1
		elseif C.direction.x <= -1 then
			C.target_tile.x = C.target_tile.x - 1
			---------------------- Y ----------------------
		elseif C.direction.y >= 1 then
			C.target_tile.y = C.target_tile.y + 1
		elseif C.direction.y <= -1 then
			C.target_tile.y = C.target_tile.y - 1
		end
		-----------------------------------------------
	elseif tile == TILE.NAV.ROTATE_TOP_LEFT then
		C.target_tile.x = C.target_tile.x + 1
		C.target_tile.y = C.target_tile.y + 1
		C.direction = {
			x = 1,
			y = 1
		}
		slow = true
	elseif tile == TILE.NAV.ROTATE_TOP_RIGHT then
		C.target_tile.x = C.target_tile.x - 1
		C.target_tile.y = C.target_tile.y + 1
		C.direction = {
			x = -1,
			y = 1
		}
		slow = true
	elseif tile == TILE.NAV.ROTATE_DOWN_LEFT then
		C.target_tile.x = C.target_tile.x + 1
		C.target_tile.y = C.target_tile.y - 1
		C.direction = {
			x = 1,
			y = -1
		}
		slow = true
	elseif tile == TILE.NAV.ROTATE_DOWN_RIGHT then
		C.target_tile.x = C.target_tile.x - 1
		C.target_tile.y = C.target_tile.y - 1
		C.direction = {
			x = -1,
			y = -1
		}
		slow = true
	elseif tile == TILE.NAV.STOP then
		log(C, "stop")
		C.traffic = false
		stop(C)
	else
		log(C, "PANIC: not a navigation tile!")
		C.traffic = false
		stop(C)
	end

	if slow then
		update_velocity(C, C.speed.slow)
	else
		update_velocity(C, C.speed.fast)
	end

	C.time.rotation = 0
end

function init(self)
	self.time = {
		acceleration = 0,
		rotation = 0,
	}

	self.instant_rotate = true
	self.instant_acceleration = true

	self.target_tile = nil
	--[[ {
		x = 8,
		y = 9
	} ]]--

	self.direction = {
		x = 0,
		y = 0,
	}

	self.danger = 0

	self.props = {
		max_speed = 650, -- в пикселях/сек
		acceleration_time = 2, -- в секундах
		rotation_time = 1, -- в секундах
		brake_time = 0.35, -- в секундах
	}

	self.speed = {
		fast = 450,
		slow = 450 * 0.5, --> 225
		accurate = 100,
	}

	self.prev_velocity = 0
	self.velocity = 0
	self.target_velocity = self.speed.fast
end

function update(self, dt)
	for timer, value in pairs(self.time) do
		self.time[timer] = value + dt
	end

	if self.target_tile then
		local current_position = go.get_position()
		local target_position = vmath.vector3(TILESIZE * self.target_tile.x - 65, TILESIZE * self.target_tile.y - 65, 0)
		
		local target_angle = vmath.quat_rotation_z(math.atan2(current_position.x - target_position.x, target_position.y - current_position.y))
		local current_angle = go.get_rotation()
		local smoothness = 0.3
		local rotation_time = math.min(self.time.rotation / self.props.rotation_time, 1)

		if self.instant_rotate then
			current_angle = target_angle
			self.instant_rotate = false
		else
			current_angle = vmath.slerp((smoothness * rotation_time) * (self.velocity / self.props.max_speed), current_angle, target_angle)

			-- local _, _, z2 = vmath.quat_to_euler(target_angle)
			-- local _, _, z1 = vmath.quat_to_euler(current_angle)
			-- 
			-- z2 = z2 * smoothness
			-- z2 = math.max(math.min(limit, z2), -limit)
			-- 
			-- current_angle = vmath.quat_rotation_z(z1 + z2)
		end
		
		go.set_rotation(current_angle)

		local tile_x, tile_y = get_tile_pos()
		local target_x, target_y = self.target_tile.x, self.target_tile.y
		if tile_x == target_x and tile_y == target_y then
			if self.traffic then
				tile_action(self)
			else
				stop(self)
			end
		end
	else
		if self.traffic then
			tile_action(self)
		elseif self.target_velocity ~= 0 then
			update_velocity(self, 0)
		end
	end

	if self.velocity ~= self.target_velocity then
		local time
		if self.target_velocity >= self.prev_velocity then
			time = self.props.acceleration_time
		else
			time = self.props.brake_time
		end
		
		time = math.min(self.time.acceleration / time, 1)
		if self.instant_acceleration then
			time = 1
			self.instant_acceleration = false
		end
		
		local target_vel = self.target_velocity
		if (self.danger or 0) > 0 then
			target_vel = 0
		end
		
		self.velocity = vmath.lerp(time, self.prev_velocity, target_vel)
	end

	if math.floor(self.velocity) ~= 0 then
		go.set_position(go.get_position() + vmath.rotate(go.get_rotation(), (vmath.vector3(0, self.velocity, 0) * dt)))
	end

	collectgarbage()
end

function on_message(self, message_id, message)
	if message_id == MSG.TRIG_RESP then
		if message.own_group == hash("danger") then
			if message.enter then
				self.danger = self.danger + 1
			else
				self.danger = math.max(self.danger - 1, 0)
			end
			
			log(self, "danger " .. self.danger)
		end
	end
end