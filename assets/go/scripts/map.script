--[[
Этот файл — часть Darkbox.

Darkbox — свободная программа: вы можете перераспространять ее и/или
изменять ее на условиях Стандартной общественной лицензии GNU в том
виде, в каком она была опубликована Фондом свободного программного
обеспечения; либо версии 3 лицензии, либо (по вашему выбору) любой
более поздней версии.

Darkbox распространяется в надежде, что она будет полезной, но БЕЗО
ВСЯКИХ ГАРАНТИЙ; даже без неявной гарантии ТОВАРНОГО ВИДА или
ПРИГОДНОСТИ ДЛЯ ОПРЕДЕЛЕННЫХ ЦЕЛЕЙ. Подробнее см. в Стандартной
общественной лицензии GNU.

Вы должны были получить копию Стандартной общественной лицензии GNU
вместе с этой программой. Если это не так, см.
<https://www.gnu.org/licenses/>.
]]

local ID = {
	AI = hash("ai")
}

local URL = {
	MCTL = msg.url("game:/player#mission"),
}

local MSG = {
	LOAD_MAP = hash("load_map"),
	SET_PAYPHONES = hash("set_payphones"),
	ASK_ENTER_VEHICLE = hash("ask_enter_vehicle"),
	ENTERED_VEHICLE_ID = hash("entered_vehicle_id"),
	SET_PROPS = hash("set_props")
}

local FACTORY = {
	PAYPHONE = msg.url("game:/factory#payphone"),
	TARGET_PTR = msg.url("game:/factory#target_ptr"),
	CAR = msg.url("game:/factory#car")
}

local TILEMAP = {
	URL = msg.url("game:/map#tilemap"),
	CARSPAWNS = hash("[carspawns]"),
	TRAFFIC = hash("[traffic]"),
}

local CARS = {}

local function randbool(chance)
	return math.random() <= (chance)
end

local function create_car(tx, ty, props, rotation)
	print(string.format("create_car: create car: index %d, TX %d, TY %d", #CARS, tx, ty))
	
	local pos; if tx and ty then
		pos = vmath.vector3(128 * tx - 64, 128 * ty - 64, 1.5)
	end
	props.index = #CARS
	
	local CAR = factory.create(FACTORY.CAR, pos, nil, props)
	CARS[#CARS+1] = CAR
	
	go.set_rotation(rotation or vmath.quat(), CAR)
end

local function load_map(name, flags)
	print(string.format("map: load map: %s", name))
	pprint(flags)

	do
		do
			print("map: cleanup")
			go.delete(CARS, true)
			-- go.delete(..., true)
			print("map: finished cleanup")
		end
		
		-- создание фабричных объектов
		do
			print("map: create fabric objects")
			
			local objects = {}
			
			local payphones = {}

			-- local err = function (errmsg)
			-- 	print("FATAL: " .. errmsg)
			-- 	msg.post("@system:", "exit", {code = 1})
			-- end
			
			local payphone = function (tx, ty)
				return {
					type = "payphone",
					position = vmath.vector3(128*tx - 64, 128*ty - 64, 1),
				}
			end
			
			if name == "metacity" then
				objects.payphones = {
					payphone(7, 3),
					payphone(8, 3),
					payphone(9, 3),
					payphone(10, 3),
				}
			else
				print("map: FATAL: no such map: " .. name)
				msg.post("@system:", "exit", {code = 1})
			end

			for key, list in pairs(objects) do
				for id, obj in ipairs(list) do
					local TYPE = obj.type
					local POS = obj.position
					
					if TYPE == "payphone" then
						print(string.format("map: create payphone: index %d", #payphones))
						local instance = collectionfactory.create(FACTORY.PAYPHONE, POS)
						payphones[#payphones+1] = instance
						
						go.animate(assert(instance[hash("/arrow")]), "position.y", go.PLAYBACK_LOOP_PINGPONG, -38, go.EASING_INOUTSINE, 2)
					elseif TYPE == "target_ptr" then
						print(string.format("map: create target pointer"))
						factory.create(FACTORY.TARGET_PTR, POS)
					end
				end
			end

			msg.post(URL.MCTL, MSG.SET_PAYPHONES, payphones)

			print("map: finished create fabric objects")
		end

		do
			print("map: scan spawners")
			
			local SPAWNER = {
				CAR = 23
			}

			local PROPS = {
				ai = false,
			}
			
			local x, y, w, h = tilemap.get_bounds(TILEMAP.URL)
			tilemap.set_visible(TILEMAP.URL, TILEMAP.CARSPAWNS, false)
			--local tiles = tilemap.get_tiles(TILEMAP.URL, TILEMAP.CARSPAWNS)
			for row = y, y + h - 1 do
				for column = x, x + w - 1 do
					local tile = assert(tilemap.get_tile_info(TILEMAP.URL, TILEMAP.CARSPAWNS, column, row), "empty tile info!")
					local index = tile.index

					if index == SPAWNER.CAR then
						local z = 0

						if tile.h_flip then z = z - 90 end
						if tile.v_flip then z = z - 90 end
						if tile.rotate_90 then z = z - 90 end
						
						create_car(column, row, PROPS, vmath.euler_to_quat(0, 0, z))
					end
				end
			end

			print("map: finished scan spawners")
		end

		-- создание трафика
		if flags.make_traffic then
			print("map: make traffic")
			
			local navtiles = {}
			
			local x, y, w, h = tilemap.get_bounds(TILEMAP.URL)
			local tiles = tilemap.get_tiles(TILEMAP.URL, TILEMAP.TRAFFIC)
			for row = y, y + h - 1 do
				for column = x, x + w - 1 do
					local tile = tiles[row][column]

					if tile ~= 0 then
						navtiles[#navtiles+1] = {
							x = column,
							y = row
						}
					end
				end
			end

			local density = flags.density
			local chance = math.floor(#navtiles * density) / #navtiles

			local PROPS = {
				ai = true,
				traffic = true,
			}
			
			for _, navtile in ipairs(navtiles) do
				if randbool(chance) then
					create_car(navtile.x, navtile.y, PROPS)
				end
			end

			print(string.format("map: navtiles stats: total %d; cars: %d; chance: %f", #navtiles, #CARS, chance))
			print("map: finished make traffic")
		end
	end collectgarbage()

	print("map: finished load map")
end

function init(self)
	load_map("metacity", {
		make_traffic = true,
		density = 0.025
	})
end

function on_message(self, message_id, message, sender)
	if message_id == MSG.LOAD_MAP then
		load_map(assert(message.name, error("expected field `name`", 2)))
	elseif message_id == MSG.ASK_ENTER_VEHICLE then
		print("map: sender ",sender," asked to enter a vehicle")
		
		local spos, range = message.position, message.range

		print("map: scan cars")
		for i, CAR in ipairs(CARS) do
			local carpos = go.get_position(CAR)
			local magic = (math.abs(carpos.x - spos.x) + math.abs(carpos.y - spos.y)) / 2
			
			if magic <= range then
				print("map: found a car nearby: ", CAR)
				
				msg.post(CAR, MSG.SET_PROPS, { ai = false })
				msg.post(sender, MSG.ENTERED_VEHICLE_ID, { CAR })
			end
		end
		print("map: end scan cars")
	end
end