--[[
Этот файл — часть Darkbox.

Darkbox — свободная программа: вы можете перераспространять ее и/или
изменять ее на условиях Стандартной общественной лицензии GNU в том
виде, в каком она была опубликована Фондом свободного программного
обеспечения; либо версии 3 лицензии, либо (по вашему выбору) любой
более поздней версии.

Darkbox распространяется в надежде, что она будет полезной, но БЕЗО
ВСЯКИХ ГАРАНТИЙ; даже без неявной гарантии ТОВАРНОГО ВИДА или
ПРИГОДНОСТИ ДЛЯ ОПРЕДЕЛЕННЫХ ЦЕЛЕЙ. Подробнее см. в Стандартной
общественной лицензии GNU.

Вы должны были получить копию Стандартной общественной лицензии GNU
вместе с этой программой. Если это не так, см.
<https://www.gnu.org/licenses/>.
]]

local ID = {
	TILEMAP = {
		THIS = msg.url("game:/map#tilemap"),
		GROUND = hash("ground"),
		TRAFFIC = hash("traffic"),
	}
}

local TILESIZE = 128

local TILE = {
	WATER = 3,
	
	CTL_CONTINUE = 7,
	CTL_STOP = 8,
	CTL_UP = 9,
	CTL_RIGHT = 10,
	CTL_DOWN = 11,
	CTL_LEFT = 12,
	CTL_ROTATE_TOP_LEFT = 13,
	CTL_ROTATE_TOP_RIGHT = 14,
	CTL_ROTATE_DOWN_LEFT = 15,
	CTL_ROTATE_DOWN_RIGHT = 16,
}

local function get_tile(layer, tx, ty)
	return tilemap.get_tile(ID.TILEMAP.THIS, layer, tx, ty)
end

local function get_tile_pos()
	local tx, ty
	do
		local pos = go.get_position()
		tx = math.floor(pos.x / TILESIZE) + 1
		ty = math.floor(pos.y / TILESIZE) + 1
	end
	return tx, ty
end

local function get_current_tile(layer)
	local tx, ty = get_tile_pos()
	return get_tile(layer, tx, ty)
end

--------------------------------------------------------------------------------

function init(self)
	self.time = {
		acceleration = 0,
		rotation = 0,
	}

	self.target_tile = nil
	--[[ {
		x = 8,
		y = 9
	} ]]--

	self.direction = {
		x = 0,
		y = 0,
	}

	self.props = {
		max_speed = 650, -- в пикселях/сек
		acceleration_time = 2, -- в секундах
		rotation_time = 1, -- в секундах
		brake_time = 0.5, -- в секундах
		traffic_mode = true
	}

	self.speed = {
		fast = 450,
		slow = 450 * 0.5, --> 225
		accurate = 100,
	}

	self.prev_velocity = 0
	self.velocity = 0
	self.target_velocity = self.speed.fast
end

function update(self, dt)
	for timer, value in pairs(self.time) do
		self.time[timer] = value + dt
	end

	local update_velocity = function (vel)
		self.target_velocity = assert(vel, "nil velocity")
		self.prev_velocity = self.velocity
		self.time.acceleration = 0
	end

	local stop = function ()
		self.target_tile = nil
		update_velocity(0)
	end

	local tile_action = function ()
		local tile = get_current_tile(ID.TILEMAP.TRAFFIC)
		local slow = false

		if not self.target_tile then
			print("redefined self.target_tile")
			local tx, ty = get_tile_pos()
			self.target_tile = {
				x = tx,
				y = ty
			}
		end

		if tile == TILE.CTL_UP then
			self.target_tile.y = self.target_tile.y + 1
			self.direction = {
				x = 0,
				y = 1
			}
		elseif tile == TILE.CTL_RIGHT then
			self.target_tile.x = self.target_tile.x + 1
			self.direction = {
				x = 1,
				y = 0
			}
		elseif tile == TILE.CTL_DOWN then
			self.target_tile.y = self.target_tile.y - 1
			self.direction = {
				x = 0,
				y = -1
			}
		elseif tile == TILE.CTL_LEFT then
			self.target_tile.x = self.target_tile.x - 1
			self.direction = {
				x = -1,
				y = 0
			}
		elseif tile == TILE.CTL_CONTINUE then
			---------------------- X ----------------------
			if self.direction.x >= 1 then
				self.target_tile.x = self.target_tile.x + 1
			elseif self.direction.x <= -1 then
				self.target_tile.x = self.target_tile.x - 1
				---------------------- Y ----------------------
			elseif self.direction.y >= 1 then
				self.target_tile.y = self.target_tile.y + 1
			elseif self.direction.y <= -1 then
				self.target_tile.y = self.target_tile.y - 1
			end
			-----------------------------------------------
		elseif tile == TILE.CTL_ROTATE_TOP_LEFT then
			self.target_tile.x = self.target_tile.x + 1
			self.target_tile.y = self.target_tile.y + 1
			self.direction = {
				x = 1,
				y = 1
			}
			slow = true
		elseif tile == TILE.CTL_ROTATE_TOP_RIGHT then
			self.target_tile.x = self.target_tile.x - 1
			self.target_tile.y = self.target_tile.y + 1
			self.direction = {
				x = -1,
				y = 1
			}
			slow = true
		elseif tile == TILE.CTL_ROTATE_DOWN_LEFT then
			self.target_tile.x = self.target_tile.x + 1
			self.target_tile.y = self.target_tile.y - 1
			self.direction = {
				x = 1,
				y = -1
			}
			slow = true
		elseif tile == TILE.CTL_ROTATE_DOWN_RIGHT then
			self.target_tile.x = self.target_tile.x - 1
			self.target_tile.y = self.target_tile.y - 1
			self.direction = {
				x = -1,
				y = -1
			}
			slow = true
		elseif tile == TILE.CTL_STOP then
			self.props.traffic_mode = false
			stop()
			print("stopped")
		else
			print("PANIC: not a control tile we're at!")
			stop()
		end

		if slow then
			update_velocity(self.speed.slow)
		else
			update_velocity(self.speed.fast)
		end

		self.time.rotation = 0
	end

	if self.target_tile then
		local current_position = go.get_position()
		local target_position = vmath.vector3(TILESIZE * self.target_tile.x - 65, TILESIZE * self.target_tile.y - 65, 0)
		
		local target_angle = vmath.quat_rotation_z(math.atan2(current_position.x - target_position.x, target_position.y - current_position.y))
		local current_angle = go.get_rotation()
		local smoothness = 0.3
		local rotation_time = math.min(self.time.rotation / self.props.rotation_time, 1)
		current_angle = vmath.slerp(smoothness * rotation_time, current_angle, target_angle)
		
		go.set_rotation(current_angle)

		local tile_x, tile_y = get_tile_pos()
		local target_x, target_y = self.target_tile.x, self.target_tile.y
		if tile_x == target_x and tile_y == target_y then
			if self.props.traffic_mode then
				tile_action()
			else
				-- not implemented
				stop()
			end
		end
	else
		if self.props.traffic_mode then
			tile_action()
		elseif self.target_velocity ~= 0 then
			update_velocity(0)
		end
	end

	if self.velocity ~= self.target_velocity then
		local time
		if self.target_velocity >= self.prev_velocity then
			time = self.props.acceleration_time
		else
			time = self.props.brake_time
		end
		time = math.min(self.time.acceleration / time, 1)
		self.velocity = vmath.lerp(time, self.prev_velocity, self.target_velocity)
	end

	if math.floor(self.velocity) ~= 0 then
		go.set_position(go.get_position() + vmath.rotate(go.get_rotation(), (vmath.vector3(0, self.velocity, 0) * dt)))
	end

	collectgarbage()
end