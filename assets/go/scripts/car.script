--[[
Этот файл — часть Darkbox.

Darkbox — свободная программа: вы можете перераспространять ее и/или
изменять ее на условиях Стандартной общественной лицензии GNU в том
виде, в каком она была опубликована Фондом свободного программного
обеспечения; либо версии 3 лицензии, либо (по вашему выбору) любой
более поздней версии.

Darkbox распространяется в надежде, что она будет полезной, но БЕЗО
ВСЯКИХ ГАРАНТИЙ; даже без неявной гарантии ТОВАРНОГО ВИДА или
ПРИГОДНОСТИ ДЛЯ ОПРЕДЕЛЕННЫХ ЦЕЛЕЙ. Подробнее см. в Стандартной
общественной лицензии GNU.

Вы должны были получить копию Стандартной общественной лицензии GNU
вместе с этой программой. Если это не так, см.
<https://www.gnu.org/licenses/>.
]]

local ID = {
	TILEMAP = {
		THIS = msg.url("game:/map#tilemap"),
		GROUND = hash("ground"),
		TRAFFIC = hash("[traffic]"),
	}
}

local ACT = {
	MOVE_FORWARD = hash("move_forward"),
	MOVE_BACKWARD = hash("move_backward"),
	MOVE_LEFT = hash("move_left"),
	MOVE_RIGHT = hash("move_right"),
	ENTER_VEHICLE = hash("enter_vehicle")
}

local MSG = {
	TRIG_RESP = hash("trigger_response"),
	SET_PROPS = hash("set_props"),
	ACQ_INPUT = hash("acquire_input_focus"),
	REL_INPUT = hash("release_input_focus"),
}

local TILESIZE = 128

local TILE = {
	WATER = 3,

	NAV = {
		CONTINUE = 7,
		STOP = 8,
		UP = 9,
		RIGHT = 10,
		DOWN = 11,
		LEFT = 12,
		ROTATE_TOP_LEFT = 13,
		ROTATE_TOP_RIGHT = 14,
		ROTATE_DOWN_LEFT = 15,
		ROTATE_DOWN_RIGHT = 16,
	},
}

go.property("index", 0)

-- симуляция дорожного движения
go.property("traffic", false)
-- автоматическое следование за плиткой
go.property("ai", true)
-- управление клавишами перемещения
go.property("control", false)

go.property("turned_on", false)

local function get_tile(layer, tx, ty)
	return tilemap.get_tile(ID.TILEMAP.THIS, layer, tx, ty)
end

local function get_tile_pos()
	local tx, ty
	do
		local pos = go.get_position()
		tx = math.floor(pos.x / TILESIZE) + 1
		ty = math.floor(pos.y / TILESIZE) + 1
	end
	return tx, ty
end

local function get_current_tile(layer)
	local tx, ty = get_tile_pos()
	return get_tile(layer, tx, ty)
end

--------------------------------------------------------------------------------

local function log(C, msg)
	print(string.format("car %d:\t\t%s", assert(C.index), msg))
end

local function stop(C)
	C.target_tile = nil
	C.accel = 0
end

local function tile_action(self)
	if not self.target_tile and self.traffic then
		log(self, "redefine target_tile")
		local tx, ty = get_tile_pos()
		self.target_tile = {
			x = tx,
			y = ty
		}
	end

	local tile = get_current_tile(ID.TILEMAP.TRAFFIC)
	local slow = false

	if tile == TILE.NAV.UP then
		self.target_tile.y = self.target_tile.y + 1
		self.direction = {
			x = 0,
			y = 1
		}
	elseif tile == TILE.NAV.RIGHT then
		self.target_tile.x = self.target_tile.x + 1
		self.direction = {
			x = 1,
			y = 0
		}
	elseif tile == TILE.NAV.DOWN then
		self.target_tile.y = self.target_tile.y - 1
		self.direction = {
			x = 0,
			y = -1
		}
	elseif tile == TILE.NAV.LEFT then
		self.target_tile.x = self.target_tile.x - 1
		self.direction = {
			x = -1,
			y = 0
		}
	elseif tile == TILE.NAV.CONTINUE then
		---------------------- X ----------------------
		if self.direction.x >= 1 then
			self.target_tile.x = self.target_tile.x + 1
		elseif self.direction.x <= -1 then
			self.target_tile.x = self.target_tile.x - 1
			---------------------- Y ----------------------
		elseif self.direction.y >= 1 then
			self.target_tile.y = self.target_tile.y + 1
		elseif self.direction.y <= -1 then
			self.target_tile.y = self.target_tile.y - 1
		end
		-----------------------------------------------
	elseif tile == TILE.NAV.ROTATE_TOP_LEFT then
		self.target_tile.x = self.target_tile.x + 1
		self.target_tile.y = self.target_tile.y + 1
		self.direction = {
			x = 1,
			y = 1
		}
		slow = true
	elseif tile == TILE.NAV.ROTATE_TOP_RIGHT then
		self.target_tile.x = self.target_tile.x - 1
		self.target_tile.y = self.target_tile.y + 1
		self.direction = {
			x = -1,
			y = 1
		}
		slow = true
	elseif tile == TILE.NAV.ROTATE_DOWN_LEFT then
		self.target_tile.x = self.target_tile.x + 1
		self.target_tile.y = self.target_tile.y - 1
		self.direction = {
			x = 1,
			y = -1
		}
		slow = true
	elseif tile == TILE.NAV.ROTATE_DOWN_RIGHT then
		self.target_tile.x = self.target_tile.x - 1
		self.target_tile.y = self.target_tile.y - 1
		self.direction = {
			x = -1,
			y = -1
		}
		slow = true
	elseif tile == TILE.NAV.STOP then
		log(self, "stop")
		self.traffic = false
		stop(self)
	else
		log(self, "PANIC: not a navigation tile!")
		self.traffic = false
		stop(self)
	end

	local max_speed = self.props.max_speed

	if not slow then
		self.target_velocity = max_speed * 0.5
	else
		self.target_velocity = max_speed * 0.35
	end

	self.time.rotation = 0
end

function init(self)
	self.time = {
		rotation = 0,
	}

	self.instant_rotate = true
	self.instant_acceleration = true

	self.target_tile = nil
	--[[ {
		x = 8,
		y = 9
	} ]]--

	self.direction = {
		x = 0,
		y = 0,
	}

	self.danger = 0

	self.props = {
		max_speed = 750, -- в пикселях/сек
		pps = 256, -- пиксели/сек
		brake_pps = 512, -- пиксели/сек
		resistance = 32, -- пиксели/сек

		angs = 140, -- в градусах/сек
		rotation_time = 1, -- в секундах
	}

	-- self.speed = {
	-- 	fast = 450,
	-- 	slow = 450 * 0.5, --> 225
	-- 	accurate = 100,
	-- }

	self.accel = nil
	self.velocity = 0
	self.target_velocity = 250

	self.rotation = 0
	self.rotate = 0

	self.engine_sound = nil
	self.asph_sound = sound.play("#asphsound")

	if self.turned_on then
		self.engine_sound = sound.play("#engine")
	end
end

function update(self, DT)
	for timer, value in pairs(self.time) do
		self.time[timer] = value + DT
	end

	if self.ai then
		if self.target_tile then
			local current_position = go.get_position()
			local target_position = vmath.vector3(TILESIZE * self.target_tile.x - 65, TILESIZE * self.target_tile.y - 65, 0)
			
			local target_angle = vmath.quat_rotation_z(math.atan2(current_position.x - target_position.x, target_position.y - current_position.y))
			local current_angle = go.get_rotation()
			local smoothness = 0.3
			local rotation_time = math.min(self.time.rotation / self.props.rotation_time, 1)

			if self.instant_rotate then
				current_angle = target_angle
				self.instant_rotate = false
			else
				current_angle = vmath.slerp((smoothness * rotation_time) * (self.velocity / self.props.max_speed), current_angle, target_angle)

				-- local _, _, z2 = vmath.quat_to_euler(target_angle)
				-- local _, _, z1 = vmath.quat_to_euler(current_angle)
				-- 
				-- z2 = z2 * smoothness
				-- z2 = math.max(math.min(limit, z2), -limit)
				-- 
				-- current_angle = vmath.quat_rotation_z(z1 + z2)
			end
			
			go.set_rotation(current_angle)

			local tile_x, tile_y = get_tile_pos()
			local target_x, target_y = self.target_tile.x, self.target_tile.y
			if tile_x == target_x and tile_y == target_y then
				if self.traffic then
					tile_action(self)
				else
					-- не реализовано!
					-- послать сообщение скрипту, определивший цель?
					stop(self)
				end
			end
		else
			if self.traffic then
				tile_action(self)
			else
				self.accel = 0
			end
		end

		if self.target_velocity then
			local target = math.floor(self.target_velocity)
			local vel = math.floor(self.velocity)

			if vel > target then
				self.accel = 0
			elseif vel < target then
				self.accel = 1
			else
				self.accel = nil
			end
		end

		if self.danger > 0 then
			self.accel = 0
		end
	end

	if self.accel then
		local pps, brake_pps = (self.props.pps * DT), (self.props.brake_pps * DT)
		
		if self.accel > 0 then
			self.velocity = self.velocity + pps
		elseif self.accel == 0 then
			self.velocity = math.max(self.velocity - brake_pps, 0)
		elseif self.accel < 0 then
			self.velocity = self.velocity - pps
		end
	elseif self.velocity ~= 0 then
		local resistance = self.props.resistance
		if math.abs(self.velocity) <= resistance then
			self.velocity = 0
		else
			if self.velocity < 0 then
				resistance = -resistance
			end
			self.velocity = self.velocity - (resistance * DT)
		end
	end

	local clamp = self.props.max_speed
	self.velocity = vmath.clamp(self.velocity, -clamp, clamp)

	do
		local angs = 0
		
		if self.rotate == 1 then
			angs = -self.props.angs
		elseif self.rotate == -1 then
			angs = self.props.angs
		end
		
		-- if self.velocity < 0 then
		-- 	angs = -angs
		-- end

		self.rotation = angs * (self.velocity / self.props.max_speed)
	end

	if math.floor(self.rotation) ~= 0 then
		local _, _, z = vmath.quat_to_euler(go.get_rotation())
		z = z + self.rotation * DT
		go.set_rotation(vmath.euler_to_quat(0, 0, z))
	end

	if math.floor(self.velocity) ~= 0 then
		go.set_position(go.get_position() + vmath.rotate(go.get_rotation(), (vmath.vector3(0, self.velocity, 0) * DT)))
	end

	local speed, inc, accel = go.get("#engine", "speed"), -0.01, (self.accel or 0)

	if accel == 1 and self.velocity >= 0 then
		inc = 0.03
	elseif accel == -1 and self.velocity <= 0 then
		inc = 0.03
	end

	go.set("#engine", "speed", vmath.clamp((speed + inc), 1.0, 2.5))
	go.set("#asphsound", "speed", vmath.clamp(math.abs(self.velocity) / self.props.max_speed, 0, 1))

	local camera_pos = go.get_position("/camera#camera")
	local car_pos = go.get_position()
	
	local diff_x = math.abs(camera_pos.x - car_pos.x) / (128 * 4)
	local diff_y = math.abs(camera_pos.y - car_pos.y) / (128 * 4)

	sound.set_gain("#engine", vmath.clamp(1.0 - (diff_x + diff_y) / 2, 0.0, 1.0))
	sound.set_gain("#asphsound", vmath.clamp(1.5 - (diff_x + diff_y) / 2, 0.0, 2.0))

	collectgarbage()
end

function on_message(self, message_id, message)
	if message_id == MSG.TRIG_RESP then
		if message.own_group == hash("danger") then
			if message.enter then
				self.danger = self.danger + 1
			else
				self.danger = math.max(self.danger - 1, 0)
			end
			
			-- log(self, "danger " .. self.danger)
		end
	elseif message_id == MSG.SET_PROPS then
		for key, value in pairs(message) do
			print("car: set prop: [",key,"] = [",value,"]")
			self[key] = value
		end

		if self.control then
			print("car: acquire input focus")
			msg.post("#", MSG.ACQ_INPUT)

			if not self.turned_on and not self.engine_sound then
				self.engine_sound = sound.play("#engine")
			end
		else
			print("car: release input focus")
			msg.post("#", MSG.REL_INPUT)
		end

		print("car: reset accel")
		self.accel = nil
	end
end

function on_input(self, action_id, action)
	if not self.control then return end
	
	if action_id == ACT.MOVE_FORWARD then
		if action.pressed then
			self.accel = 1
		elseif action.released then
			self.accel = nil
		end
	elseif action_id == ACT.MOVE_BACKWARD then
		if action.pressed then
			self.accel = -1
		elseif action.released then
			self.accel = nil
		end
	elseif action_id == ACT.MOVE_LEFT then
		if action.pressed then
			self.rotate = -1
		elseif action.released then
			self.rotate = nil
		end
	elseif action_id == ACT.MOVE_RIGHT then
		if action.pressed then
			self.rotate = 1
		elseif action.released then
			self.rotate = nil
		end
	end
end
