--[[
Этот файл — часть Darkbox.

Darkbox — свободная программа: вы можете перераспространять ее и/или
изменять ее на условиях Стандартной общественной лицензии GNU в том
виде, в каком она была опубликована Фондом свободного программного
обеспечения; либо версии 3 лицензии, либо (по вашему выбору) любой
более поздней версии.

Darkbox распространяется в надежде, что она будет полезной, но БЕЗО
ВСЯКИХ ГАРАНТИЙ; даже без неявной гарантии ТОВАРНОГО ВИДА или
ПРИГОДНОСТИ ДЛЯ ОПРЕДЕЛЕННЫХ ЦЕЛЕЙ. Подробнее см. в Стандартной
общественной лицензии GNU.

Вы должны были получить копию Стандартной общественной лицензии GNU
вместе с этой программой. Если это не так, см.
<https://www.gnu.org/licenses/>.
]]

local ID = {
	TILEMAP = {
		THIS = msg.url("game:/map#tilemap"),
		GROUND = hash("ground"),
		TRAFFIC = hash("[traffic]"),
	}
}

local MSG = {
	TRIG_RESP = hash("trigger_response"),
}

local TILESIZE = 128

local TILE = {
	WATER = 3,

	NAV = {
		CONTINUE = 7,
		STOP = 8,
		UP = 9,
		RIGHT = 10,
		DOWN = 11,
		LEFT = 12,
		ROTATE_TOP_LEFT = 13,
		ROTATE_TOP_RIGHT = 14,
		ROTATE_DOWN_LEFT = 15,
		ROTATE_DOWN_RIGHT = 16,
	},
}

go.property("index", 0)
-- симуляция дорожного движения
go.property("traffic", false)
-- автоматическое следование за плиткой
go.property("ai", true)

local function get_tile(layer, tx, ty)
	return tilemap.get_tile(ID.TILEMAP.THIS, layer, tx, ty)
end

local function get_tile_pos()
	local tx, ty
	do
		local pos = go.get_position()
		tx = math.floor(pos.x / TILESIZE) + 1
		ty = math.floor(pos.y / TILESIZE) + 1
	end
	return tx, ty
end

local function get_current_tile(layer)
	local tx, ty = get_tile_pos()
	return get_tile(layer, tx, ty)
end

--------------------------------------------------------------------------------

local function log(C, msg)
	print(string.format("car %d:\t\t%s", assert(C.index), msg))
end

local function stop(C)
	C.target_tile = nil
	C.accel = 0
end

local function tile_action(self)
	if not self.target_tile and self.traffic then
		log(self, "redefine target_tile")
		local tx, ty = get_tile_pos()
		self.target_tile = {
			x = tx,
			y = ty
		}
	end

	local tile = get_current_tile(ID.TILEMAP.TRAFFIC)
	local slow = false

	if tile == TILE.NAV.UP then
		self.target_tile.y = self.target_tile.y + 1
		self.direction = {
			x = 0,
			y = 1
		}
	elseif tile == TILE.NAV.RIGHT then
		self.target_tile.x = self.target_tile.x + 1
		self.direction = {
			x = 1,
			y = 0
		}
	elseif tile == TILE.NAV.DOWN then
		self.target_tile.y = self.target_tile.y - 1
		self.direction = {
			x = 0,
			y = -1
		}
	elseif tile == TILE.NAV.LEFT then
		self.target_tile.x = self.target_tile.x - 1
		self.direction = {
			x = -1,
			y = 0
		}
	elseif tile == TILE.NAV.CONTINUE then
		---------------------- X ----------------------
		if self.direction.x >= 1 then
			self.target_tile.x = self.target_tile.x + 1
		elseif self.direction.x <= -1 then
			self.target_tile.x = self.target_tile.x - 1
			---------------------- Y ----------------------
		elseif self.direction.y >= 1 then
			self.target_tile.y = self.target_tile.y + 1
		elseif self.direction.y <= -1 then
			self.target_tile.y = self.target_tile.y - 1
		end
		-----------------------------------------------
	elseif tile == TILE.NAV.ROTATE_TOP_LEFT then
		self.target_tile.x = self.target_tile.x + 1
		self.target_tile.y = self.target_tile.y + 1
		self.direction = {
			x = 1,
			y = 1
		}
		slow = true
	elseif tile == TILE.NAV.ROTATE_TOP_RIGHT then
		self.target_tile.x = self.target_tile.x - 1
		self.target_tile.y = self.target_tile.y + 1
		self.direction = {
			x = -1,
			y = 1
		}
		slow = true
	elseif tile == TILE.NAV.ROTATE_DOWN_LEFT then
		self.target_tile.x = self.target_tile.x + 1
		self.target_tile.y = self.target_tile.y - 1
		self.direction = {
			x = 1,
			y = -1
		}
		slow = true
	elseif tile == TILE.NAV.ROTATE_DOWN_RIGHT then
		self.target_tile.x = self.target_tile.x - 1
		self.target_tile.y = self.target_tile.y - 1
		self.direction = {
			x = -1,
			y = -1
		}
		slow = true
	elseif tile == TILE.NAV.STOP then
		log(self, "stop")
		self.traffic = false
		stop(self)
	else
		log(self, "PANIC: not a navigation tile!")
		self.traffic = false
		stop(self)
	end

	local max_speed = self.props.max_speed

	if not slow then
		self.target_velocity = max_speed
	else
		self.target_velocity = max_speed * 0.5
	end

	self.time.rotation = 0
end

function init(self)
	self.time = {
		rotation = 0,
	}

	self.instant_rotate = true
	self.instant_acceleration = true

	self.target_tile = nil
	--[[ {
		x = 8,
		y = 9
	} ]]--

	self.direction = {
		x = 0,
		y = 0,
	}

	self.danger = 0

	self.props = {
		max_speed = 350, -- в пикселях/сек
		rotation_time = 1, -- в секундах
		pps = 256, -- пиксели/сек
		brake_pps = 512, -- пиксели/сек
		resistance = 64, -- пиксели/сек
	}

	-- self.speed = {
	-- 	fast = 450,
	-- 	slow = 450 * 0.5, --> 225
	-- 	accurate = 100,
	-- }

	self.accel = nil
	self.velocity = 0
	self.target_velocity = 250
end

function update(self, DT)
	for timer, value in pairs(self.time) do
		self.time[timer] = value + DT
	end

	if self.ai then
		if self.target_tile then
			local current_position = go.get_position()
			local target_position = vmath.vector3(TILESIZE * self.target_tile.x - 65, TILESIZE * self.target_tile.y - 65, 0)
			
			local target_angle = vmath.quat_rotation_z(math.atan2(current_position.x - target_position.x, target_position.y - current_position.y))
			local current_angle = go.get_rotation()
			local smoothness = 0.3
			local rotation_time = math.min(self.time.rotation / self.props.rotation_time, 1)

			if self.instant_rotate then
				current_angle = target_angle
				self.instant_rotate = false
			else
				current_angle = vmath.slerp((smoothness * rotation_time) * (self.velocity / self.props.max_speed), current_angle, target_angle)

				-- local _, _, z2 = vmath.quat_to_euler(target_angle)
				-- local _, _, z1 = vmath.quat_to_euler(current_angle)
				-- 
				-- z2 = z2 * smoothness
				-- z2 = math.max(math.min(limit, z2), -limit)
				-- 
				-- current_angle = vmath.quat_rotation_z(z1 + z2)
			end
			
			go.set_rotation(current_angle)

			local tile_x, tile_y = get_tile_pos()
			local target_x, target_y = self.target_tile.x, self.target_tile.y
			if tile_x == target_x and tile_y == target_y then
				if self.traffic then
					tile_action(self)
				else
					-- не реализовано!
					-- послать сообщение скрипту, определивший цель?
					stop(self)
				end
			end
		else
			if self.traffic then
				tile_action(self)
			else
				self.accel = 0
			end
		end

		if self.target_velocity then
			local target = math.floor(self.target_velocity)
			local vel = math.floor(self.velocity)

			if vel > target then
				self.accel = 0
			elseif vel < target then
				self.accel = 1
			else
				self.accel = nil
			end
		end

		if self.danger > 0 then
			self.accel = 0
		end
	end

	if self.accel then
		local pps, brake_pps = (self.props.pps * DT), (self.props.brake_pps * DT)
		
		if self.accel == 1 then -- speed
			self.velocity = self.velocity + pps
		elseif self.accel == 0 then -- brake
			self.velocity = math.max(self.velocity - brake_pps, 0)
		elseif self.accel == -1 then -- reverse
			self.velocity = self.velocity - pps
		end
	else
		local resistance = self.props.resistance
		if self.velocity < 0 then
			resistance = -self.props.resistance
		end
		self.velocity = self.velocity - (resistance * DT)
	end
	
	self.velocity = math.max(math.min(self.props.max_speed, self.velocity), -self.props.max_speed)

	if math.floor(self.velocity) ~= 0 then
		go.set_position(go.get_position() + vmath.rotate(go.get_rotation(), (vmath.vector3(0, self.velocity, 0) * DT)))
	end

	collectgarbage()
end

function on_message(self, message_id, message)
	if message_id == MSG.TRIG_RESP then
		if message.own_group == hash("danger") then
			if message.enter then
				self.danger = self.danger + 1
			else
				self.danger = math.max(self.danger - 1, 0)
			end
			
			-- log(self, "danger " .. self.danger)
		end
	end
end