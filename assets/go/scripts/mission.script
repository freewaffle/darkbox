--[[
Этот файл — часть Darkbox.

Darkbox — свободная программа: вы можете перераспространять ее и/или
изменять ее на условиях Стандартной общественной лицензии GNU в том
виде, в каком она была опубликована Фондом свободного программного
обеспечения; либо версии 3 лицензии, либо (по вашему выбору) любой
более поздней версии.

Darkbox распространяется в надежде, что она будет полезной, но БЕЗО
ВСЯКИХ ГАРАНТИЙ; даже без неявной гарантии ТОВАРНОГО ВИДА или
ПРИГОДНОСТИ ДЛЯ ОПРЕДЕЛЕННЫХ ЦЕЛЕЙ. Подробнее см. в Стандартной
общественной лицензии GNU.

Вы должны были получить копию Стандартной общественной лицензии GNU
вместе с этой программой. Если это не так, см.
<https://www.gnu.org/licenses/>.
]]

local locale = require("lib.locale").get_page("game")

local URL = {
	SOUND = {
		SP = "game:/sound#sp",
		SP_MAX = 7
	},

	PLAYER = {
		THIS = msg.url("game:/player"),
		SCRIPT = msg.url("game:/player#script")
	},

	FACTORY = {
		PAYPHONE = msg.url("game:/factory#payphone"),
		TARGET_PTR = msg.url("game:/factory#target_ptr")
	},

	HUD = msg.url("game:/hud#hud"),
	MAP_CTL = msg.url("game:/map#script")
}

local MSG = {
	ACTIVATE_MISSION = hash("activate_mission"),
	UPDATE_SPEECH = hash("update_speech"),
	SOUND_DONE = hash("sound_done"),
	SET_PAYPHONES = hash("set_payphones")
}

local ID = {
	ARROW = hash("/arrow"),
	PAYPHONE = hash("/payphone"),
	POSITION = {
		Y = hash("position.y")
	}
}

------------------------------------------------------------------------

local speechpart_count = 0
local speechpart_prev = 0
local had_speech_before = false
local speech_stack = {}
local speech_pop_timer = nil

local PAYPHONES = {}
local TARGET_PTRS = {}

local function add_object(obj)
	local TYPE = obj.type

	if TYPE == "payphone" then
		local instance = collectionfactory.create(URL.FACTORY.PAYPHONE, obj.position)
		PAYPHONES[#PAYPHONES+1] = instance

		go.animate(instance[ID.ARROW], ID.POSITION.Y, go.PLAYBACK_LOOP_PINGPONG, -38, go.EASING_INOUTSINE, 2)
	elseif TYPE == "target_ptr" then
		local instance = factory.create(URL.FACTORY.TARGET_PTR, obj.position)
		TARGET_PTRS[#TARGET_PTRS+1] = instance
	else
		error("unknown type: " .. TYPE, 2)
	end
end

local function toggle_object(data)
	local CLASS, OBJ_ID, MODE = data[1], data[2], data[3]

	-- assert(type(CLASS) == "string", error("invalid type of CLASS field", 2))
	-- assert(type(OBJ_ID) == "string", error("invalid type of OBJ_ID field", 2))

	if MODE == true then
		MODE = "enable"
	elseif MODE == false then
		MODE = "disable"
	else
		error("invalid mode: " .. MODE, 2)
	end

	if CLASS == "payphone" then
		local payphone = assert(
			PAYPHONES[OBJ_ID],
			string.format("no object of class %s exists with this id: " .. OBJ_ID, CLASS)
		)
		msg.post(payphone[ID.ARROW], MODE)
	else
		error("unknown object class", 2)
	end
end

local function speechpart_handle(self, message_id, message, handler)
	speechpart_count = speechpart_count - 1
	if speechpart_count > 0 and message_id == MSG.SOUND_DONE then
		local magic = (math.random(-1, 2) / 20)
		local r
		while true do
			r = math.random(1, URL.SOUND.SP_MAX)
			if r ~= speechpart_prev then
				speechpart_prev = r
				break
			end
		end
		sound.play(URL.SOUND.SP .. r, {
			--delay = 0.1 * (magic + 0.05),
			speed = 1 + magic
		}, speechpart_handle)
	else
		speechpart_count = 0
	end
end

local function play_speech(count)
	if count then
		speechpart_count = speechpart_count + count
	end
	math.randomseed(os.time())
	speechpart_prev = math.random(1, URL.SOUND.SP_MAX)
	sound.play(URL.SOUND.SP .. speechpart_prev, nil, speechpart_handle)
end

local function hide_speech()
	msg.post(URL.HUD, MSG.UPDATE_SPEECH, {
		show = false
	})
	had_speech_before = false
end

local function pop_speech()
	local speech = table.remove(speech_stack, 1)
	if speech then
		msg.post(URL.HUD, MSG.UPDATE_SPEECH, {
			show = true,
			text = speech
		})
		if not had_speech_before then
			local times = 12 -- math.ceil(#speech * 0.05)
			play_speech(times)
			had_speech_before = true
		end
	else
		hide_speech()
	end
end

------------------------------------------------------------------------

local function m_make(fn_init, fn_update)
	if type(fn_init) == "table" then
		fn_update = fn_init.update
		fn_init = fn_init.init
	end
	
	if type(fn_init) ~= "function" then
		error("fn_init: not a function", 2)
	end

	if type(fn_update) ~= "function" and type(fn_update) ~= "nil" then
		error("fn_update: not a function", 2)
	end
	
	return {
		env = {},
		fn_init = fn_init,
		fn_update = fn_update
	}
end

-- restart `speech_pop_timer` timer
local function m_restart_spt()
	if speech_pop_timer then timer.cancel(speech_pop_timer) end
	speech_pop_timer = timer.delay(6, true, pop_speech)
end

local function m_add_speech(speech)
	local had_not_speech = #speech_stack <= 0

	for i,s in ipairs(speech) do
		local type = type(s)
		if type == "string" then
			speech_stack[#speech_stack+1] = s
		elseif type ~= "nil" then
			error(string.format("invalid type of field %d: expected string, found %s", i, type(s)), 2)
		end
	end

	if had_not_speech then
		-- отображаем речь:
		pop_speech()
		
		m_restart_spt()
	end
end

local function m_remove_speech(n)
	if n then
		table.remove(speech_stack, n)
	else
		speech_stack = {}
	end
end

local function m_interrupt_speech(speech)
	speechpart_count = 0
	sound.stop(URL.SOUND.SPEECHPART)

	m_remove_speech()
	had_speech_before = false
	m_add_speech(speech)
end

local function m_add_object(otype, props)
	local allowed = {
		"payphone",
		"target_ptr"
	}

	local valid = false

	if type(otype) == "string" then
		for n, str in ipairs(allowed) do
			if otype == str then
				-- верный тип, продолжаем
				valid = true
				break
			end
		end
	end

	if valid then
		local obj = {
			type = otype,
			position = assert(props.position, "expected field `position`")
		}
		
		add_object(obj)
	else
		if otype(otype) == "string" then
			error(string.format("invalid object type '%s'", otype), 2)
		else
			error(string.format("invalid object type, expected string"), 2)
		end
	end
end

local function m_get_player_tile()
	local pos = go.get_position(URL.PLAYER.THIS)
	local x, y = 1 + math.floor(pos.x / 127), 1 + math.floor(pos.y / 127)
	collectgarbage()
	return x, y
end

------------------------------------------------------------------------

local fn_init, fn_update, m_env;

local mphones = { 1, 2, 3, 4 }
local activated_payphone;

local finished = true
local disabled = false

-- ```lua
-- local switches = {
--     { 1, false },
--     { 2, true }
-- }
-- m_toggle_payphones(switches) --> выключит телефон 1 и включит телефон 2
--
-- m_toggle_payphones(true) --> передача true/false включит/выключит телефоны **с миссиями**
-- ```
local function m_toggle_payphones(switches)
	if type(switches) == "boolean" then
		for n, id in ipairs(PAYPHONES) do
			local data = { "payphone", n, switches }
			toggle_object(data)
		end
	elseif type(switches) == "table" then
		for n, switch in ipairs(switches) do
			local data = { "payphone", switch[1], switch[2] }
			toggle_object(data)
		end
	end
end

local function m_finish(succeed, disable_payphone)
	if disable_payphone then
		table.remove(mphones, activated_payphone)
	end
	finished = true
	
	fn_init, fn_update = nil, nil

	collectgarbage()
end

------------------------------------------------------------------------

local progress = 0

local scripts = {
	start = {
		init = function ()
			m_add_speech({
				locale[1]
			})
		end
	},
	
	[1] = {
		init = function (env)
			m_interrupt_speech({
				locale[2]
			})
		end,
		
		update = function (env)
			local tx, ty = m_get_player_tile()
			if tx == 4 and ty == 4 then
				m_interrupt_speech({
					locale[3]
				})
				m_finish(true, true)
			end
		end
	}
}

local ms_start = m_make(scripts.start.init)

local ms = {
	m_make(scripts[1])
}

local function try(fn, arg)
	if type(fn) == "function" then
		local handler = function (msg)
			print(string.format("mission: ERROR:%d: %s", progress, msg))
			msg.post("@system:", "exit", {code = 1})
		end

		xpcall(function() fn(arg) end, handler)
	else
		error("not a function", 2)
	end
end

local function fetch(n)
	local current = ms[n]
	fn_init = current.fn_init
	fn_update = current.fn_update
	m_env = current.env
end

local function next_mission()
	return ms[progress+1]
end

local function start_next_mission()
	progress = progress + 1
	fetch(progress)
	
	collectgarbage()

	finished = false
	try(assert(fn_init, "undeclared init function"))
end

------------------------------------------------------------------------

function init(self)
	if ms_start then
		try(ms_start.fn_init)
	end

	-- m_add_object("target_ptr", {
	-- 	position = vmath.vector3(64, 64, 1)
	-- })

	collectgarbage()
end

function update(self, dt)
	if fn_update then
		try(fn_update, m_env)
	end

	if next_mission() == nil then
		if not disabled then
			print("mission: no next script found")
			m_toggle_payphones(false)
			disabled = true
		end
		return
	else
		disabled = false
	end

	do
		local player_pos = go.get_position(URL.PLAYER.THIS)

		for _, ptr in ipairs(TARGET_PTRS) do
			local arrow = ptr[ID.ARROW]
			local arrow_pos = go.get_position(arrow)
			local angle = vmath.quat_rotation_z(math.atan2(-player_pos.x + arrow_pos.x, player_pos.y - arrow_pos.y))
			go.set_rotation(angle, arrow)
		end
	end

	collectgarbage()
end

function on_message(self, message_id, message, sender)
	if message_id == MSG.ACTIVATE_MISSION then
		local activate = false
		
		if message.payphone_id ~= nil then
			for n, id in ipairs(mphones) do
				local payphone = PAYPHONES[id][ID.PAYPHONE]
				if payphone == message.payphone_id then
					activated_payphone = id
					activate = true
					break
				end
			end
		else
			print("mission: force activate mission since `payphone_id` is not present")
			activate = true
		end
		
		if activate and ms[progress+1] ~= nil and finished then
			m_toggle_payphones(false)
			start_next_mission()
		end
	elseif message_id == MSG.SET_PAYPHONES then
		print("mission: update payphones list")
		PAYPHONES = {}
		for i,p in ipairs(message) do
			PAYPHONES[i] = p
		end
	end
end