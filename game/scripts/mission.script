--[[
Этот файл — часть Darkbox.

Darkbox — свободная программа: вы можете перераспространять ее и/или
изменять ее на условиях Стандартной общественной лицензии GNU в том
виде, в каком она была опубликована Фондом свободного программного
обеспечения; либо версии 3 лицензии, либо (по вашему выбору) любой
более поздней версии.

Darkbox распространяется в надежде, что она будет полезной, но БЕЗО
ВСЯКИХ ГАРАНТИЙ; даже без неявной гарантии ТОВАРНОГО ВИДА или
ПРИГОДНОСТИ ДЛЯ ОПРЕДЕЛЕННЫХ ЦЕЛЕЙ. Подробнее см. в Стандартной
общественной лицензии GNU.

Вы должны были получить копию Стандартной общественной лицензии GNU
вместе с этой программой. Если это не так, см.
<https://www.gnu.org/licenses/>.
]]

local locale = require("lib.locale").get_page("game")

local URL = {
	SOUND = {
		SP = "game:/sound#sp",
		SP_MAX = 7
	},

	PLAYER = {
		THIS = msg.url("game:/player"),
		SCRIPT = msg.url("game:/player#script")
	},

	HUD = msg.url("game:/ui#hud"),
	MAP_CTL = msg.url("game:/map#script")
}

local MSG = {
	ACTIVATE_MISSION = hash("activate_mission"),
	UPDATE_SPEECH = hash("update_speech"),
	SOUND_DONE = hash("sound_done"),
	SET_PAYPHONES = hash("set_payphones"),
	TOGGLE = hash("toggle")
}

------------------------------------------------------------------------

local speechpart_count = 0
local speechpart_prev = 0

local function speechpart_handle(self, message_id, message, handler)
	speechpart_count = speechpart_count - 1
	if speechpart_count > 0 and message_id == MSG.SOUND_DONE then
		local magic = (math.random(-1, 2) / 20)
		local r
		while true do
			r = math.random(1, URL.SOUND.SP_MAX)
			if r ~= speechpart_prev then
				speechpart_prev = r
				break
			end
		end
		sound.play(URL.SOUND.SP .. r, {
			--delay = 0.1 * (magic + 0.05),
			speed = 1 + magic
		}, speechpart_handle)
	else
		speechpart_count = 0
	end
end

local function play_speech(count)
	if count then
		speechpart_count = speechpart_count + count
	end
	math.randomseed(os.time())
	speechpart_prev = math.random(1, URL.SOUND.SP_MAX)
	sound.play(URL.SOUND.SP .. speechpart_prev, nil, speechpart_handle)
end

local speech_stack = {}

local had_speech_before = false

local function hide_speech()
	msg.post(URL.HUD, MSG.UPDATE_SPEECH, {
		show = false
	})
	had_speech_before = false
end

local function pop_speech()
	local speech = table.remove(speech_stack, 1)
	if speech then
		msg.post(URL.HUD, MSG.UPDATE_SPEECH, {
			show = true,
			text = speech
		})
		if not had_speech_before then
			-- sound.play(ID.SOUND.SPEECH)
			local times = 12 -- math.ceil(#speech * 0.05)
			play_speech(times)
			had_speech_before = true
		end
	else
		hide_speech()
	end
end

local speech_pop_timer = nil

------------------------------------------------------------------------

local function m_make(fn_init, fn_update)
	if type(fn_init) ~= "function" then
		error("fn_init: not a function", 2)
	end

	if type(fn_update) ~= "function" and type(fn_update) ~= "nil" then
		error("fn_update: not a function", 2)
	end
	
	return {
		env = {},
		fn_init = fn_init,
		fn_update = fn_update
	}
end

local function m_smart_make(table)
end

-- restart `speech_pop_timer` timer
local function m_restart_spt()
	if speech_pop_timer then timer.cancel(speech_pop_timer) end
	speech_pop_timer = timer.delay(6, true, pop_speech)
end

local function m_add_speech(speech)
	local had_not_speech = #speech_stack <= 0

	for i,s in ipairs(speech) do
		local type = type(s)
		if type == "string" then
			speech_stack[#speech_stack+1] = s
		elseif type ~= "nil" then
			error(string.format("invalid type of field %d: expected string, found %s", i, type(s)), 2)
		end
	end

	if had_not_speech then
		-- отображаем речь:
		pop_speech()
		
		m_restart_spt()
	end
end

local function m_remove_speech(n)
	if n then
		speech_stack[n] = nil
	else
		speech_stack = {}
	end
end

local function m_interrupt_speech(speech)
	speechpart_count = 0
	sound.stop(URL.SOUND.SPEECHPART)

	m_remove_speech()
	had_speech_before = false
	m_add_speech(speech)
end

local function m_get_player_tile()
	local pos = go.get_position(URL.PLAYER.THIS)
	local x, y = 1 + math.floor(pos.x / 127), 1 + math.floor(pos.y / 127)
	collectgarbage()
	return x, y
end

------------------------------------------------------------------------

local fn_init, fn_update;

local payphones = {}
local mphones = { 1, 2, 3, 4 }
local activated_payphone;

local disabled = false

--
-- ```lua
-- local switches = {
--     { 1, false },
--     { 2, true }
-- }
-- m_toggle_payphones(switches) --> выключит телефон 1 и включит телефон 2
--
-- m_toggle_payphones(true) --> передача true/false включит/выключит телефоны с миссиями
-- ```
local function m_toggle_payphones(switches)
	if type(switches) == "boolean" then
		for n, id in ipairs(mphones) do
			msg.post(URL.MAP_CTL, MSG.TOGGLE, { "payphone", id, switches })
		end
	elseif type(switches) == "table" then
		for n, switch in ipairs(switches) do
			msg.post(URL.MAP_CTL, MSG.TOGGLE, { "payphone", switch[1], switch[2] })
		end
	end
end

local function m_finish(succeed, deprecate_phone)
	if deprecate_phone then
		table.remove(mphones, activated_payphone)
	end
	m_toggle_payphones(true)
	
	fn_init, fn_update = nil, nil

	collectgarbage()
end

------------------------------------------------------------------------

local progress = 0

local scripts = {
	start = {
		init = function ()
			m_add_speech({
				locale[1]
			})
		end
	},
	
	[1] = {
		init = function ()
			-- title
			m_interrupt_speech({
				locale[2],
			})
			--m_finish(true, true)
		end,
		
		update = function ()
			print(m_get_player_tile())
		end
	}
}

local ms_start = m_make(scripts.start.init)

local ms = {
	m_make(scripts[1].init, scripts[1].update)
}

local function try(fn, arg)
	if type(fn) == "function" then
		local handler = function (msg)
			print(string.format("ERROR:%d: %s", progress, msg))

			msg.post("@system:", "exit", {code = 1})
		end

		xpcall(function() fn(arg) end, handler)
	else
		error("not a function", 2)
	end
end

local function fetch(n)
	local current = ms[n]
	fn_init = current.fn_init
	fn_update = current.fn_update
end

local function next_mission()
	return ms[progress+1]
end

local function start_next_mission()
	progress = progress + 1
	fetch(progress)
	
	collectgarbage()
	
	try(assert(fn_init, "undeclared init function"))
end

------------------------------------------------------------------------

collectgarbage()

function init(self)
	if ms_start then
		try(ms_start.fn_init)
		collectgarbage()
	end
end

function update(self, dt)
	if fn_update then
		try(fn_update)
		collectgarbage()
	end

	if not disabled and next_mission() == nil then
		print("no next script found")
		disabled = true
		m_toggle_payphones(false)
	end
end

function on_message(self, message_id, message, sender)
	if message_id == MSG.ACTIVATE_MISSION then
		local activate = false
		
		if message.payphone_id ~= nil then
			for n, id in ipairs(mphones) do
				if payphones[id] == message.payphone_id then
					activated_payphone = id
					activate = true
					break
				end
			end
		else
			print("force activating mission since `payphone_id` is not present")
			activate = true
		end
		
		if activate and ms[progress+1] ~= nil then
			m_toggle_payphones(false)
			start_next_mission()
		end
	elseif message_id == MSG.SET_PAYPHONES then
		if type(message) == "table" then
			payphones = message
		end
	end
end