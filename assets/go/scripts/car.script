--[[
Этот файл — часть Darkbox.

Darkbox — свободная программа: вы можете перераспространять ее и/или
изменять ее на условиях Стандартной общественной лицензии GNU в том
виде, в каком она была опубликована Фондом свободного программного
обеспечения; либо версии 3 лицензии, либо (по вашему выбору) любой
более поздней версии.

Darkbox распространяется в надежде, что она будет полезной, но БЕЗО
ВСЯКИХ ГАРАНТИЙ; даже без неявной гарантии ТОВАРНОГО ВИДА или
ПРИГОДНОСТИ ДЛЯ ОПРЕДЕЛЕННЫХ ЦЕЛЕЙ. Подробнее см. в Стандартной
общественной лицензии GNU.

Вы должны были получить копию Стандартной общественной лицензии GNU
вместе с этой программой. Если это не так, см.
<https://www.gnu.org/licenses/>.
]]

local ID = {
	TILEMAP = {
		THIS = msg.url("game:/map#tilemap"),
		GROUND = hash("ground"),
		TRAFFIC = hash("traffic"),
	}
}

local TILESIZE = 128

local TILE = {
	WATER = 3,
	CTL_CONTINUE = 7,
	CTL_STOP = 8,
	CTL_UP = 9,
	CTL_ROTATE_TOP_LEFT = 13,
}

local function get_tile_pos()
	local tx, ty
	do
		local pos = go.get_position()
		tx = math.floor(pos.x / TILESIZE) + 1
		ty = math.floor(pos.y / TILESIZE) + 1
	end
	return tx, ty
end

local function get_current_tile(layer)
	local tx, ty = get_tile_pos()
	local tile = tilemap.get_tile(ID.TILEMAP.THIS, layer, tx, ty)
	return tile
end

--------------------------------------------------------------------------------

function init(self)
	self.time = {
		acceleration = 0,
		rotation = 0,
	}

	self.target_tile = {
		x = 8,
		y = 9
	}

	self.direction = {
		x = 0,
		y = 0,
	}

	self.props = {
		max_angle = 2, -- в градусах
		max_speed = 250, -- в пикселях/сек
		acceleration_time = 2, -- в секундах
		rotation_time = 1, -- в секундах
		fade_speed = false,
		traffic_mode = true
	}

	self.prev_velocity = 0

	self.velocity = 250
	go.set_position(vmath.vector3((128 * 8) - 65, (128 * 8) - 65, 1.5))
end

function update(self, dt)
	for timer, value in pairs(self.time) do
		self.time[timer] = value + dt
	end

	if self.target_tile then
		local current_position = go.get_position()
		local target_position = vmath.vector3(TILESIZE * self.target_tile.x - 65, TILESIZE * self.target_tile.y - 65, 0)

		if self.props.fade_speed then
			local mid_x = math.abs(target_position.x - current_position.x)
			local mid_y = math.abs(target_position.y - current_position.y)
			local mid_position = (mid_x + mid_y) / 2
			local strength = 0.5
			self.velocity = math.min(mid_position * strength, self.props.max_speed)
		end
		
		local target_angle = vmath.quat_rotation_z(math.atan2(current_position.x - target_position.x, target_position.y - current_position.y))
		local current_angle = go.get_rotation()
		local smoothness = 0.3
		local rotation_time = math.min(self.time.rotation / self.props.rotation_time, 1)
		current_angle = vmath.lerp(smoothness * rotation_time, current_angle, target_angle)
		
		go.set_rotation(current_angle)

		local tile_x, tile_y = get_tile_pos()
		local target_x, target_y = self.target_tile.x, self.target_tile.y
		if tile_x == target_x and tile_y == target_y then
			if self.props.traffic_mode then
				local tile = get_current_tile(ID.TILEMAP.TRAFFIC)

				if tile == TILE.CTL_UP then
					self.target_tile.y = self.target_tile.y + 1
					self.direction = {
						x = 0,
						y = 1
					}
				elseif tile == TILE.CTL_CONTINUE then
					---------------------- X ----------------------
					if self.direction.x >= 1 then
						self.target_tile.x = self.target_tile.x + 1
					elseif self.direction.x <= -1 then
						self.target_tile.x = self.target_tile.x - 1
					---------------------- Y ----------------------
					elseif self.direction.y >= 1 then
						self.target_tile.y = self.target_tile.y + 1
					elseif self.direction.y <= -1 then
						self.target_tile.y = self.target_tile.y - 1
					end
					-----------------------------------------------
				else
					print("PANIC: not a control tile we're at!")
					self.target_tile = nil
				end

				self.time.rotation = 0
			else
				self.time.acceleration = 0
				self.prev_velocity = self.velocity
				self.target_tile = nil
			end
		end
	else
		local time = math.min(self.time.acceleration / self.props.acceleration_time, 1)
		self.velocity = vmath.lerp(time, self.prev_velocity, 0)
	end

	go.set_position(go.get_position() + vmath.rotate(go.get_rotation(), (vmath.vector3(0, self.velocity, 0) * dt)))

	collectgarbage()
end