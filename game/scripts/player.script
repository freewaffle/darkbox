--[[
Этот файл — часть Darkbox.

Darkbox — свободная программа: вы можете перераспространять ее и/или
изменять ее на условиях Стандартной общественной лицензии GNU в том
виде, в каком она была опубликована Фондом свободного программного
обеспечения; либо версии 3 лицензии, либо (по вашему выбору) любой
более поздней версии.

Darkbox распространяется в надежде, что она будет полезной, но БЕЗО
ВСЯКИХ ГАРАНТИЙ; даже без неявной гарантии ТОВАРНОГО ВИДА или
ПРИГОДНОСТИ ДЛЯ ОПРЕДЕЛЕННЫХ ЦЕЛЕЙ. Подробнее см. в Стандартной
общественной лицензии GNU.

Вы должны были получить копию Стандартной общественной лицензии GNU
вместе с этой программой. Если это не так, см.
<https://www.gnu.org/licenses/>.
]]

local ACTION = {
	MOVE_FORWARD = hash("move_forward"),
	MOVE_BACKWARD = hash("move_backward"),
	MOVE_LEFT = hash("move_left"),
	MOVE_RIGHT = hash("move_right")
}

--[[ цитата из @dark6ox:
я заметил, что функции, которые изменяют свойства объектов, вместе с обычными строками принимают также хэши.
предполагаю, что во время выполнения обычные строки хэшируются и передаются движку (согласно документации,
движок использует хэш в качестве ссылок), поэтому все найденные ссылки я вынес в отдельную таблицу.
там они хэшируются при загрузке, а не во время выполнения, так что это плюс к оптимизации! ]]

local MSG = {
	UPDATE_HP = hash("update_hp"),
	ENABLE = hash("enable"),
	DISABLE = hash("disable"),
	ACQ_INPUT = hash("acquire_input_focus"),
	REL_INPUT = hash("release_input_focus"),
	TRIG_RESP = hash("trigger_response"),
	ACTIVATE_MISSION = hash("activate_mission"),
}

-- идентификаторы игровых объектов.
local ID = {
	-- player:

	THIS = msg.url("game:/player"),
	THIS_SCRIPT = msg.url("game:/player#script"),
	SPRITE = msg.url("game:/player#sprite"),

	-- animations:

	ANIM = {
		PLAYER_MOVING = hash("player_moving"),
		PLAYER_STAND = hash("player_1"),
	},

	-- properties:

	PROP = {
		POSITION = hash("position"),
		ANIMATION = hash("animation"),
		ZOOM = hash("orthographic_zoom"),
	},

	-- external:

	-- mission controller
	MCTL = msg.url("game:/player#mission"),

	CAMERA = {
		THIS = msg.url("game:/camera"),
		CAM = msg.url("game:/camera#camera"),
	},

	TILEMAP = {
		THIS = msg.url("game:/map#tilemap"),
		GROUND = hash("ground")
	},

	UI = {
		HUD = msg.url("game:/ui#hud")
	},

	GROUP = {
		PAYPHONE = hash("payphone")
	}
}

local TILEID = {
	WATER = 3
}

local CONST = {
	MOVEMENT_SPEED = 100,
	MAX_HP = 100,
	CAMERA_FOLLOWS_DIRECTION = true,
}

--------------------------------------------------------------------------------

local hp = CONST.MAX_HP
local dead = hp <= 0
local angle = vmath.quat()

-- local function move_camera(lerp)
-- 	local command = "update_pos"
-- 	if lerp then
-- 		command = "lerp_pos"
-- 	end
-- 	msg.post("/camera#script", command, { go.get_position() })
-- end

local function rotate_to_pos(target_position)
	-- FIXME: анимация свойства "rotation" вызывает ошибку
	-- go.animate("#sprite", "rotation", go.PLAYBACK_ONCE_FORWARD, to, go.EASING_OUTCUBIC, 0.5)
	angle = vmath.quat_rotation_z(math.atan2(target_position.x, -target_position.y))
	go.set_rotation(angle)
end

local function hp_trigger()
	dead = hp <= 0
	if not dead then
		msg.post(ID.SPRITE, MSG.ENABLE)
	else
		sprite.play_flipbook(ID.SPRITE, ID.ANIM.PLAYER_STAND)
		msg.post(ID.SPRITE, MSG.DISABLE)
	end
end

local function set_hp(to)
	if to == nil then
		to = CONST.MAX_HP
	else
		to = math.min(to, 0)
	end

	hp = to

	msg.post(ID.UI.HUD, MSG.UPDATE_HP, {to})
	hp_trigger()
end

local function get_current_tile(layer, pos)
	if pos == nil then
		pos = go.get_position()
	end
	local TILESIZE = 128
	local tx, ty = math.floor(pos.x / TILESIZE) + 1, math.floor(pos.y / TILESIZE) + 1
	return tilemap.get_tile(ID.TILEMAP.THIS, layer, tx, ty)
end

local function tile_trigger(pos)
	if pos.x >= 0 and pos.y >= 0 then
		local tile_id = get_current_tile(ID.TILEMAP.GROUND, pos)
		if tile_id == TILEID.WATER then
			set_hp(0)
		end
	else
		--print("death reason: pos < 0")
		set_hp(0)
	end
end

local function move_camera(to, duration, easing)
	if not duration then
		duration = 0
		easing = go.EASING_LINEAR
	end
	
	if not easing then
		easing = go.EASING_OUTCUBIC
	end
	
	go.animate(ID.CAMERA.THIS, ID.PROP.POSITION, go.PLAYBACK_ONCE_FORWARD, to, easing, duration)
end

local function zoom_camera(to, duration, easing)
	duration = duration or 0
	easing = easing or go.EASING_OUTCUBIC

	go.animate(ID.CAMERA.CAM, ID.PROP.ZOOM, go.PLAYBACK_ONCE_FORWARD, to, easing, duration)
end

--------------------------------------------------------------------------------

function init(self)
	self.velocity = vmath.vector3()
	
	----------------
	-- 1. intro pos

	local TX, TY = 6, 3
	local P = vmath.vector3(128*TX-64, 128*TY-64, 1)
	local M = 1

	go.set_position(P)
	go.set_position(vmath.vector3(P.x*M, P.y*M, P.z), ID.CAMERA.THIS)

	----------------
	-- 2. intro zoom

	--camera.set_orthographic_zoom(ID.CAMERA.CAM, 0.5)
	go.set(ID.CAMERA.CAM, "orthographic_zoom", 0.5)
	zoom_camera(1.5, 2)

	collectgarbage()
	msg.post(ID.THIS_SCRIPT, MSG.ACQ_INPUT)
end

function update(self, dt)
	local pos = go.get_position()
	
	if self.velocity.x ~= 0 or self.velocity.y ~= 0 then
		-- делает скорость при двунаправленном движении визуально симметричной
		-- к скорости с одним направлением
		if self.velocity.x ~= 0 and self.velocity.y ~= 0 then
			self.velocity = self.velocity * 0.8
		end

		go.set_rotation(angle)
		pos = go.get_position() + vmath.rotate(angle, (self.velocity * dt))
		go.set_position(pos)

		tile_trigger(pos)

		if CONST.CAMERA_FOLLOWS_DIRECTION and self.velocity.y ~= 0 then
			if self.velocity.y > 0 then
				pos = pos + vmath.rotate(angle, vmath.vector3(0, 128, 0))
			else
				pos = pos - vmath.rotate(angle, vmath.vector3(0, 128, 0))
			end
		end
		
		self.velocity = vmath.vector3()
	end

	move_camera(pos, 1, go.EASING_OUTCUBIC)
	
	--pos = nil
	collectgarbage()

	--hp_trigger()
end

function on_message(self, message_id, message, sender)
	if message_id == MSG.TRIG_RESP then
		if message.group == ID.GROUP.PAYPHONE and message.enter then
			msg.post(ID.MCTL, MSG.ACTIVATE_MISSION, { id = message.other_id })
		end
	end
end

function on_input(self, action_id, action)
	-- удалить, если есть процессы, не требующие живого игрока:
	if dead then return end

	local moved = false

	if action_id == ACTION.MOVE_FORWARD then
		self.velocity.y = CONST.MOVEMENT_SPEED
		moved = true
	elseif action_id == ACTION.MOVE_BACKWARD then
		self.velocity.y = -CONST.MOVEMENT_SPEED
		moved = true
	elseif action_id == ACTION.MOVE_LEFT then
		self.velocity.x = -CONST.MOVEMENT_SPEED
		moved = true
	elseif action_id == ACTION.MOVE_RIGHT then
		self.velocity.x = CONST.MOVEMENT_SPEED
		moved = true
	elseif not action_id and action.x and action.y then
		local w, h = window.get_size()
		rotate_to_pos(vmath.vector3(w/2 - action.x, h/2 - action.y, 0))
	end

	if moved then
		local no_anim = go.get(ID.SPRITE, ID.PROP.ANIMATION) == ID.ANIM.PLAYER_STAND
		if action.pressed or no_anim then
			sprite.play_flipbook(ID.SPRITE, ID.ANIM.PLAYER_MOVING)
		elseif action.released then
			sprite.play_flipbook(ID.SPRITE, ID.ANIM.PLAYER_STAND)
			--move_camera(go.get_position())
		end
	end
	
	collectgarbage()
end